# -*- coding: utf-8 -*-
"""
Created on Tue Jan 26 21:27:15 2021

@author: erwan
"""

import os
import sys
from time import time

import h5py
import pandas as pd
import vaex
from tables.exceptions import NoSuchNodeError


def hdf2df(
    fname,
    columns=None,
    isotope=None,
    load_wavenum_min=None,
    load_wavenum_max=None,
    verbose=True,
    store_kwargs={},
    engine="auto",
):
    """Load a HDF5 line databank into a Pandas DataFrame.

    Adds HDF5 metadata in ``df.attrs``

    Parameters
    ----------
    fname : str
        HDF5 file name
    columns: list of str
        list of columns to load. If ``None``, returns all columns in the file.
    isotope: str
        load only certain isotopes : ``'2'``, ``'1,2'``, etc. If ``None``, loads
        everything. Default ``None``.
    load_wavenum_min, load_wavenum_max: float (cm-1)
        load only specific wavelength.

    Other Parameters
    ----------------
    store_kwargs: dict
        arguments forwarded to :py:meth:`~pandas.io.pytables.read_hdf`
    engine: ``'h5py'``, ``'pytables'``, ``'vaex'``, ``'auto'``
        which HDF5 library to use. If ``'auto'``, try to guess. Note: ``'vaex'``
        uses ``'h5py'`` compatible HDF5.

    Returns
    -------
    df: pandas Dataframe
        dataframe containing all lines or energy levels

    Examples
    --------

    ::


        path = getDatabankEntries("HITEMP-OH")['path'][0]
        df = hdf2df(path)

        df = hdf2df(path, columns=['wav', 'int'])

        df = hdf2df(path, isotope='2')
        df = hdf2df(path, isotope='1,2)

        df = hdf2df(path, load_wavenum_min=2300, load_wavenum_max=2500)

    Notes
    -----

    DataFrame metadata in ``df.attrs`` is still experimental in Pandas and can be lost
    during ``groupby, pivot, join or loc`` operations on the Dataframe.
    See https://stackoverflow.com/questions/14688306/adding-meta-information-metadata-to-pandas-dataframe

    Always check for existence !

    """

    # Load :
    t0 = time()

    if engine == "auto":
        # See if it looks like PyTables
        with pd.HDFStore(fname, mode="r") as store:
            if store.get_storer("df"):
                engine = "pytables"
            else:
                engine = "h5py"

    if engine == "pytables":
        # Selection
        where = []
        if load_wavenum_min is not None:
            where.append(f"wav > {load_wavenum_min}")
        if load_wavenum_max is not None:
            where.append(f"wav < {load_wavenum_max}")
        if isotope:
            where.append(f'iso in {isotope.split(",")}')

        # Load
        try:
            df = pd.read_hdf(fname, columns=columns, where=where, **store_kwargs)
        except TypeError as err:
            if "reading from a Fixed format store" in str(err):
                raise TypeError(
                    f"radis.io.hdf5.hdf2df can only be used to load specific HDF5 files generated in a 'Table' which allows to select only certain columns or rows. Here the file {fname} is in 'Fixed' format. Regenerate it ? If it's a cache file of a .par file, load the .par file directly ?"
                )
            else:
                raise
        except NoSuchNodeError as err:
            # Probably tried to read a Vaex/h5py HDF5 file forcing "engine='pytables'"
            raise AttributeError(
                f"file {fname} does not seem to have been generated by Pytables. Try using `engine='vaex'` in hdf2df"
            ) from err
        # Add metadata:
        with pd.HDFStore(fname, mode="r") as store:
            df.attrs.update(store.get_storer("df").attrs.metadata)
    elif engine == "vaex":
        # Open file
        assert len(store_kwargs) == 0
        try:
            df = vaex.open(fname)
        except OSError as err:
            import radis

            if radis.AUTO_UPDATE_DATABASE:

                def update_pytables_to_vaex(fname):
                    """Convert a HDF5 file generated from PyTables to a
                    Vaex-friendly HDF5 format, preserving metadata"""

                    print(
                        f"Cannot read {fname} with Vaex's HDF5 library. `radis.AUTO_UPDATE_DATABASE` is set to `True`, auto-updating it to a Vaex HDF5 file"
                    )
                    df = pd.read_hdf(fname)
                    df = vaex.from_pandas(df)
                    if fname.endswith(".h5"):
                        fname_vaex = fname.replace(".h5", ".hdf5")
                    else:
                        fname_vaex = fname

                    # Read metadata
                    with pd.HDFStore(fname, mode="r") as store:
                        file_metadata = store.get_storer("df").attrs.metadata

                    # Write Vaex file
                    df.export_hdf5(fname_vaex)
                    df.close()  # try to fix file not closed()  TODO: remove?
                    del df  # same TODO

                    with h5py.File(fname_vaex, "a") as hf:
                        # Add metadata
                        for k, v in file_metadata.items():
                            hf.attrs[k] = v

                    if fname != fname_vaex:
                        # Remove initial file
                        os.remove(fname)

                    print(f"Converted to Vaex's HDF5 format {fname_vaex}")

                    return fname_vaex

                fname = update_pytables_to_vaex(fname)
                df = vaex.open(fname)
            else:
                raise OSError(
                    f"Cannot read {fname} with Vaex's HDF5 library. Try using engine='pytables' in hdf2df, delete the file to re-download it, or set `radis.AUTO_UPDATE_DATABASE = True` in your script to auto-update to Vaex HDF5 file"
                ) from err

        # Selection
        selection = True
        # limitation : so far the df.select(df.iso in isotope.split(",")) syntax
        # fails in Vaex (and worse: still returns something.)
        # For the moment, only implement with one isotope.
        # TODO : add all cases manually...
        if isotope is not None:
            if not isinstance(isotope, int):
                try:
                    isotope = int(isotope)
                except:
                    raise NotImplementedError(
                        f"When reading HDF5 in vaex mode, selection works for a single isotope only (got {isotope})"
                    )
        if (
            load_wavenum_min is not None
            and load_wavenum_max is not None
            and isotope is not None
        ):
            df.select(
                (df.wav > load_wavenum_min)
                & (df.wav < load_wavenum_max)
                & (df.iso == isotope)
            )
        elif load_wavenum_min is not None and load_wavenum_max is not None:
            df.select((df.wav > load_wavenum_min) & (df.wav < load_wavenum_max))
        elif load_wavenum_min is not None and isotope is not None:
            df.select((df.wav > load_wavenum_min) & (df.iso == isotope))
        elif load_wavenum_max is not None and isotope is not None:
            df.select((df.wav < load_wavenum_max) & (df.iso == isotope))
        elif load_wavenum_min is not None:
            df.select(df.wav > load_wavenum_min)
        elif load_wavenum_max is not None:
            df.select(df.wav < load_wavenum_max)
        elif isotope is not None:
            df.select(df.iso == isotope)
        else:
            selection = False

        # Load
        df = df.to_pandas_df(column_names=columns, selection=selection)

        # Add metadata to DataFrame:
        with h5py.File(fname, "r") as hf:
            df.attrs.update(dict(hf.attrs))
    else:
        raise NotImplementedError

    if verbose >= 3:
        from radis.misc.printer import printg

        printg(
            f"Generated dataframe from {fname} in {time()-t0:.2f}s ({len(df)} rows, {len(df.columns)} columns, {sys.getsizeof(df)*1e-6:.2f} MB)"
        )

    return df


#%%

if __name__ == "__main__":

    import pytest

    print("Testing factory:", pytest.main(["../test/io/test_hdf5.py"]))
